# 4. Protocol Specification

This document details the network protocol used by the Encrypted P2P Messenger. A strict adherence to this protocol is required for compatibility between different versions of the application.

## 4.1. Constants

The following constants are defined to ensure that all clients can communicate effectively.

```rust
const PORT_DEFAULT: u16 = 12345;
const MAX_PACKET_SIZE: usize = 8 * 1024 * 1024;  // 8 MiB
const FILE_CHUNK_SIZE: usize = 64 * 1024;         // 64 KiB
const AES_KEY_SIZE: usize = 32;                   // 256 bits
const AES_NONCE_SIZE: usize = 12;                 // 96 bits (GCM standard)
const RSA_KEY_BITS: usize = 2048;
const HANDSHAKE_TIMEOUT_SECS: u64 = 15;
```

## 4.2. Cryptography

The protocol relies on a combination of cryptographic primitives to ensure confidentiality, integrity, and authenticity.

-   **RSA**: 2048-bit RSA with OAEP padding and SHA-256 (RSA-OAEP-SHA256) is used for identity verification and the initial exchange of cryptographic material.
-   **AES**: AES-256-GCM is used for symmetric encryption of all messages after the handshake is complete.
-   **Nonce**: A 12-byte (96-bit) nonce is randomly generated for each message. This is the standard size for AES-GCM and provides a high level of security against reuse.
-   **Fingerprint**: The fingerprint of a user's public key is the SHA-256 hash of the PEM-encoded key, represented as a lowercase hexadecimal string.
-   **Transport Format (Encrypted)**: Encrypted messages are sent over the wire in the following format: `nonce(12) || ciphertext || tag(16)`. The 16-byte authentication tag is generated by GCM and is used to verify the integrity and authenticity of the message.

## 4.3. Network Protocol

### TCP Framing (Length-Prefixed)

To ensure that messages can be reliably sent and received over a TCP stream, a simple length-prefixing scheme is used.

1.  The payload (the data to be sent) is serialized into a `Vec<u8>`.
2.  The length of the payload is checked to ensure it does not exceed `MAX_PACKET_SIZE`.
3.  A 4-byte header, representing the length of the payload as a big-endian `u32`, is sent.
4.  The payload itself is then sent.

The receiver reads the 4-byte header first to determine the size of the incoming payload, and then reads that many bytes from the stream.

### Handshake (Protocol v2)

The handshake is the most critical part of the protocol. It establishes a secure, forward-secret session between two peers.

1.  **Version Negotiation**: The client and server exchange their supported protocol versions. If the versions are incompatible, the connection is terminated. This prevents downgrade attacks.
2.  **RSA Public Key Exchange**: Both peers exchange their long-term RSA public keys. These keys are used to verify the identity of the peers via their fingerprints.
3.  **X25519 Ephemeral Key Exchange**: For each new session, both peers generate a new, temporary X25519 key pair. These ephemeral keys are exchanged.
4.  **ECDH Computation**: A shared secret is computed using the local private ephemeral key and the remote public ephemeral key.
5.  **HKDF-SHA256 Key Derivation**: The shared secret from the ECDH computation is used as input to the HKDF-SHA256 key derivation function to generate a unique 32-byte AES session key.
6.  **Chat ID Exchange**: The client sends a `chat_id` to the host. This allows the host to associate the new session with an existing chat or create a new one, ensuring both peers are synchronized.
7.  **Encrypted Communication**: All further communication is encrypted with the newly derived AES session key.

## 4.4. Message Format

All messages sent after the handshake are of the `ProtocolMessage` enum type, which is serialized using `bincode`.

```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum ProtocolMessage {
    Text {
        text: String,
        timestamp: u64
    },
    FileMeta {
        filename: String,
        size: u64
    },
    FileChunk {
        chunk: Vec<u8>,
        seq: u64
    },
    FileEnd,
    Ping,
}
```

## 4.5. Invite Links

Invite links are a convenient way to share contact information. They are base64-encoded JSON objects with the following structure:

```json
{
  "name": "Alice",
  "address": "192.168.1.10:12345", // Optional
  "fingerprint": "a1b2c3d4e5f6...",
  "public_key": "-----BEGIN PUBLIC KEY-----\n..."
}
```

-   The `address` field is optional. If it is not included, the recipient will need to manually enter the host and port of the peer they wish to connect to.
-   The `fingerprint` and `public_key` are used to verify the identity of the contact.
